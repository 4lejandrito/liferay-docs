# Creating form Field Types

The Forms application contains many useful field types out-of-the-box, and those
field types are highly configurable. Most use cases will be met with one of the
existing field types. If you're reading this, however, your use case probably
wasn't met with the default field types. For example, perhaps you need a
dedicated *time* field. You can use a text field and add a tip to tell users
something like *enter the time in the format `hour:minute`*, but some users will
still enter something indecipherable, like *8:88*. To meet this need, add a
*time* field to @product@'s Forms application. 

<!--Once this is done successfully, take a picture-->

In this tutorial, learn to 

- create a module that adds a form field type with a basic text input field and
    the default field configuration options
- add JavaScript to modify the behavior of the field type. Here you'll leverage
    the AlloyUI `timepicker` to transform the basic input field into a dedicated
    *Time* field type.

In a separate tutorial (not yet written), learn to add custom configuration
options to your field types. <!-- What about adding custom configuration options to the
out-of-the-box field types? Is that possible or desirable? -->

## Anatomy of a Field Type Module

The `dynamic-data-mapping-type-*` modules in @product@'s source code (inside the
*Forms and Workflow* application suite) are good templates to follow when
developing your own field types. For example, look at the directory structure of
the `dynamic-data-mapping-type-paragraph` module in the Forms and Workflow
application suite:

    bnd.bnd
    build.gradle
    src
    └── main
        ├── java
        │   └── com
        │       └── liferay
        │           └── dynamic
        │               └── data
        │                   └── mapping
        │                       └── type
        │                           └── paragraph
        │                               └── internal
        │                                   ├── ParagraphDDMFormFieldRenderer.java
        │                                   ├── ParagraphDDMFormFieldType.java
        │                                   └── ParagraphDDMFormFieldTypeSettings.java
        └── resources
            ├── content
            │   ├── Language.properties
            │   └── Language_xx_XX.properties
            │   └── ...
            └── META-INF
                └── resources
                    ├── config.js
                    ├── paragraph_field.js
                    ├── paragraph.soy
                    └── paragraph.soy.js

+$$$

**Blade CLI Template:** There's a [Blade
CLI](/developer/tutorials/-/knowledge_base/7-0/blade-cli) template you can use
to generate you the project skeleton, some basic configuration, and give you a
head start on dependency management. To generate your form field type project
with Blade CLI, enter

    blade create -t form-field-type -p com.liferay.docs.formfieldtype -c Time ddm-type-time

$$$

Your field type module is nearly identical in structure to those found in
@product@, as presented above. You won't need a `*TypeSettings` class in your
initial module (see the tutorial on adding settings to your form field types to
learn more about `*TypeSettings`), and the `*.soy.js` is generated from the
`*.soy` file at compile time. These are the Java classes and resources you'll
need to create:

- `*DDMFormFieldRenderer.java`: Controls the rendering of the template. Sets the
    language, declares the namespace, and loads the template resources on
    activation of the Component. Extending the abstract class that implements
    the `DDMFormFieldRenderer` makes your work here easier.
- `*DDMFormFieldType.java`: Define the form field type in the backend. If you
    extend the abstract class that implements the interface, you automatically
    include the default form configuration options for your form field type. In
    that case, override the interface's `getName` method and you're done. To see
    the default configuration options your form field type will inherit, look at
    the `DefaultDDMFormFieldTypeSettings` class in the
    `dynamic-data-mapping-form-field-type` module.
- `config.js`: Autogenerated if you use Blade CLI, `config.js` defines the
    dependencies of all declared JavaScript components.
- `[name-of-field-type]_field.js`: The JavaScript file that models your field.
- `[name-of-field-type].soy`: The template that defines the appearance of the field. 
- `Language_xx.properties`: Define any terms that need to be 
    [translated into different languages](/developer/tutorials/-/knowledge_base/7-0/localizing-your-application).

<!-- Add the additional classes from the Google doc when this intro is split
out, according to the form fields tutorial planning section -->

In addition to the Java classes, Soy templates, and JavaScript files, @product@
applications contain a `bnd.bnd` file to manage the module's metadata, and a
`build.gradle` file to manage its dependencies. This example follows those
patterns.

+$$$

**Form field types with Blade CLI:** If you want a head start, the basic module
developed in this tutorial can be generated with a single [Blade
CLI](/developer/tutorials/-/knowledge_base/7-0/blade-cli) command:

    blade create -t form-field -p com.liferay.docs.formfield -c Time ddm-type-time

This gives you a `ddm-type-time` module with a similar structure to the one
outlined above. The Java classes will be in the package
`com.liferay.docs.formfield` under `src/main/java/` and the frontend resources
(JavaScript and Soy files) are in `sr/main/resources/META-INF/resources`.

$$$

Start by creating the OSGi Component that marks your class as an implementation
of `DDMFormFieldType`.

## Creating a `DDMFormFieldType` Component

If you're creating a *Time* field type, define the Component at the top of your
`*DDMFormFieldType` class like this:

    @Component(
      immediate = true,
      property = {
        "ddm.form.field.type.display.order:Integer=8",
        "ddm.form.field.type.icon=star-o",
        "ddm.form.field.type.js.class.name=Liferay.DDM.Field.Time",
        "ddm.form.field.type.js.module=liferay-ddm-form-field-time",
        "ddm.form.field.type.label=time-field-type-label",
        "ddm.form.field.type.name=time"
      },
      service = DDMFormFieldType.class
    )

Define the field type's properties (`property=...`) and declare that you're
implementing the `DDMFormFieldType` service (`service=...`).

`DDMFormFieldType` Components can have several properties:

`ddm.form.field.type.display.order`
: Integer that defines the field type's position in the *Choose a Field Type* dialog of the form builder.

`ddm.form.field.type.icon`
: The icon to be used for the field type. Choosing one of the [Lexicon
Experience Language icons](http://liferay.github.io/lexicon/content/icons-lexicon/) makes your form
field blends in with the existing form field types.

`ddm.form.field.type.js.class.name`
: The field type's JavaScript class name--the JavaScript file is used to define
the field type's behavior.

`ddm.form.field.type.js.module`
: The name of the JavaScript module--provided to the Form engine so the module
can be loaded when needed.

`ddm.form.field.type.label`
: The field type's label. Its localized value appears in the *Choose a Field
Type* dialog.

`ddm.form.field.type.name`
: The name of the field type is used by the `DDMFormValuesFactory` to add all
field types to the forms UI.
<!-- Check this -->

Next code the class itself.

## Implementing `DDMFormFieldType`

Implementing the field type in Java is made easier because of
`BaseDDMFormFieldType`, an abstract class you can leverage in your code.

After extending `BaseDDMFormFieldType`, override the `getName` method by
specifying the name of your new field type:

    public class TimeDDMFormFieldType extends BaseDDMFormFieldType {
        @Override
        public String getName() {
            return "time";
        }
    }

That's all there is to defining the field type. Next determine how your field
type is rendered.

## Rendering Field Types

Before you get to the frontend coding necessary to render your field type,
there's another Component to define and a Java class to code.

The Component only has one property, `ddm.form.field.type.name`, and then you
declare that you're adding a `DDMFormFieldRenderer` implementation to the OSGi
framework:

    @Component(
        immediate = true, 
        property = "ddm.form.field.type.name=time",
        service = DDMFormFieldRenderer.class
    )

There's another abstract class to leverage, this time
`BaseDDMFormFieldRenderer`. It gives you a default implementation of the
`render` method, the only required method for implementing the API. The form
engine calls the render method for every form field type present in a form, and
returns the plain HMTL of the rendered field type. The abstract implementation
also includes some utility methods. Here's what the time field's
`DDMFormFieldRenderer` looks like:

    public class TimeDDMFormFieldRenderer extends BaseDDMFormFieldRenderer {

        @Override
        public String getTemplateLanguage() {
            return TemplateConstants.LANG_TYPE_SOY;
        }

        @Override
        public String getTemplateNamespace() {
            return "ddm.time";
        }

        @Override
        public TemplateResource getTemplateResource() {
            return _templateResource;
        }

        @Activate
        protected void activate(Map<String, Object> properties) {
            _templateResource = getTemplateResource("/META-INF/resources/time.soy");
        }

        private TemplateResource _templateResource;

    }

Here you're declaring the templating language (Soy closure templates), the
template namespace (`ddm.time`), and pointing to the location of the templates
within your module (`/META-INF/resource/time.soy`). On activation of the
Component, the static resources in you module will be loaded in the OSGi
runtime.
<!-- Refine that paragraph if necessary -->

+$$$

**Note:** [Closure templates](https://developers.google.com/closure/templates/)
are a templating system for building UI elements. @product@ developers chose to
build the Forms UI with closure templates because they enable a smooth,
responsive repainting of the UI as a user enters data. With closure templates
there's no need to make calls to server side logic for rendering the field
template when the UI is updated by the user.

$$$

Now it's time to write the template you referenced in the renderer: `time.soy`
in the case of the time field type.

Create

    src/main/resources/META-INF/resources/time.soy

and populate it with these contents:

    {namespace ddm}

    /**
     * Prints the DDM form time field.
     *
     * @param label
     * @param name
     * @param readOnly
     * @param required
     * @param showLabel
     * @param tip
     * @param value
     */
    {template .time autoescape="deprecated-contextual"}
        <div class="form-group liferay-ddm-form-field-time" data-fieldname="{$name}">
            {if $showLabel}
                <label class="control-label">
                    {$label}

                    {if $required}
                        <span class="icon-asterisk text-warning"></span>
                    {/if}
                </label>

                {if $tip}
                    <p class="liferay-ddm-form-field-tip">{$tip}</p>
                {/if}
            {/if}

            <input class="field form-control" id="{$name}" name="{$name}" {if $readOnly}readonly{/if} type="text" value="{$value}">
        </div>
    {/template}

There are three important things to do in the template:

1.  Define the template namespace. The template namespace allows you to define
    multiple templates for your field type by adding the namespace as a prefix.
    <!-- Why is this beneficial?-->

        {namespace ddm}

2.  Describe the template parameters. The template above uses some of the
    parameters as flags to display or hide some parts of the HTML (for example,
    the `$required` parameter). If you extend `BaseDDMFormFieldRenderer`, all
    the listed parameters are passed by default.
   <!--Might be better to remove them from the template and instead just list
   them. Also, we didn't actually need to do this step because of the abstract
   class doing it for us, but confirm this is true-->
    <!-- A figure with a screenshot of the time configuration sidebar or one of
    the default field config sidebars would be helpful-->


        /**
         * Prints the DDM form time field.
         *
         * @param label
         * @param name
         * @param readOnly
         * @param required
         * @param showLabel
         * @param tip
         * @param value
         */

3.  Write the template logic (everything encapsulated by the
    `{template}...{/template}` block). In the above example the template does
    these things:
    - Checks whether to show the label of the field, and if so, add it.
    - Checks if the field is required, and add `icon-asterisk` if it is.
    - Checks if a tip is provided, and display it.
    - Provides the markup for the time field in the `<input>` tag. In this case
    a text input field is defined.

Once you have your template defined, write the JavaScript file modeling your
field. Call it `time_field.js` and give it these contents:

    AUI.add('liferay-ddm-form-field-time', function(A) {
        var TimeField = A.Component.create({
            ATTRS : {
                type : {
                    value : 'time'
                }
            },

            EXTENDS : Liferay.DDM.Renderer.Field,
            NAME : 'liferay-ddm-form-field-time',

            prototype : {}
        });

        Liferay.namespace('DDM.Field').Time = TimeField;
    }, '', {
        requires : [ 'liferay-ddm-form-renderer-field' ]
    });

The JavaScript above creates a component called `TimeField`. The component
extends `Liferay.DDM.Renderer.Field`, which gives you automatic injection of the
default field parameters. 

+$$$

**Note:** Extending the Java class `TimeDDMFormFieldRenderer` gave you access to
the default parameters in the backend, and extending the JavaScript component
`Liferay.DDM.Renderer.Field` injects the parameters into your JavaScript
component so you can automatically refer to them in the soy template.

$$$

All that's left to do is create the `config.js` file:

    ;
    (function() {
        AUI().applyConfig({
            groups : {
                'field-time' : {
                    base : MODULE_PATH + '/',
                    combine : Liferay.AUI.getCombine(),
                    modules : {
                        'liferay-ddm-form-field-time' : {
                            condition : {
                                trigger : 'liferay-ddm-form-renderer'
                            },
                            path : 'time_field.js',
                            requires : [ 'liferay-ddm-form-renderer-field' ]
                        },
                        'liferay-ddm-form-field-time-template' : {
                            condition : {
                                trigger : 'liferay-ddm-form-renderer'
                            },
                            path : 'time.soy.js',
                            requires : [ 'soyutils' ]
                        }
                    },
                    root : MODULE_PATH + '/'
                }
            }
        });
    })();

This file is entirely boilerplate, and you'll never need anything different if
you follow the conventions described above. In fact, if you use Blade CLI to
generate a field type module, you won't need to modify anything in this file.
So what is the `config.js` file for? It's a JavaScript file that defines the
dependencies of the declared JavaScript components (`requires...`), and where
the files are located (`path...`). The `config.js` is used by the Alloy loader
when it satisfies dependencies for each JavaScript component. For more
information about the Alloy loader please visit
[https://github.com/liferay/liferay-amd-loader#amd-module-loader](https://github.com/liferay/liferay-amd-loader#amd-module-loader).

If you build and deploy your new field type module, you'll see that you get
exactly what you described in the `time.soy` file. A single text input field. Of
course, that's not what you want! You need a time picker.

## Adding Behavior to the Field

If you want to do more than simply provide a text input field, define the
behavior in the `time_field.js` file. To add an AlloyUI timepicker, first
specify that your component requires the `aui-timepicker` in the `requires...`
block: 

    {
        requires: ['aui-timepicker','liferay-ddm-form-renderer-field']
    }

Since you're now changing the default rendering of the field, overwrite the base
`render` logic and instantiate the time picker. This occurs in the `propiotype`
block:

    prototype: {
        render: function() {

            var instance = this;

            TimeField.superclass.render.apply(instance, arguments);

            instance._timePicker = new A.TimePicker(
                {
                    trigger: instance.getInputSelector(),
                    popover: {
                        zIndex: 1
                    }
                }
            );
        }

Invoke the original render method--it prints markup required by the Alloy time
picker. Then instantiate the time picker, passing the field type input as a
`trigger`. See the [Alloy documentation for more
information](http://alloyui.com/tutorials/timepicker/). 

Now when the field is rendered, there's a real time picker!

<!--Add figure showing the time picker in action-->

Now you know how to create a new field type and define its behavior. Currently,
the field type only contains the default settings it inherits from its
superclasses. If that's not sufficinet, create additional settings for your
field type. See the next tutorial (not yet written) to learn how.

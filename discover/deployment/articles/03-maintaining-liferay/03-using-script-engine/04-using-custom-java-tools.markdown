# Using Custom Java Tools in the Script Engine

Users of Liferay's script engine face several challenges, especially regarding
debugging and logging. One approach to overcome these challenges is to develop
custom Java utilities that can be called from your scripts. These utilities can
write to a custom log file or the Liferay log file. You can also place
breakpoints in your utility code and step through it using your favorite
debugger. Liferay's OSGi-based module framework makes it easy to invoke custom
Java utilities from your script, regardless of the scripting language you're
using. First, we'll explain how to create custom Java utilities and then we'll
show how you can invoke them from a script.

## Creating a Scripting Utilities Project

How do you create a scripting utilities project? You need to create an API
module to define the method signatures of the methods that your project will
make available. You also need to create an implementation module to implement
the methods defined by the API project. An easy way to set up your scripting
utilities project is to use a multi-project Gradle configuration and to use
[Blade Tools](https://github.com/gamerson/blade.tools) to create your API and
implementation projects as subprojects. See the
[Creating Liferay Components](/develop/tutorials/-/knowledge_base/7-0/creating-liferay-components)
tutorial for more information about using Blade Tools to create API and
implementation modules for Liferay. The example project for this article is
available here:
[https://github.com/liferay/liferay-docs/tree/master/discover/deployment/code/com.liferay.docs.scriptutil](https://github.com/liferay/liferay-docs/tree/master/discover/deployment/code/com.liferay.docs.scriptutil).

Suppose that your project has a directory structure like this:

    - `com.liferay.docs.scriptutil`
        - `build.gradle`
        - `settings.gradle`
        - com.liferay.docs.scriptutil.api`
            - `src`
                - `main`
                    - `java`
                        `com.liferay.docsscriptutil.api`
                            - `ScriptUtil.java`
            - `bnd.bnd`
            - `build.gradle`
        - com.liferay.docs.scriptutil.impl`
            - `src`
                - `main`
                    - `java`
                        `com.liferay.docsscriptutil.impl`
                            - `ScriptUtilImpl.java`
            - `bnd.bnd`
            - `build.gradle`

This is the directory structure of the sample `com.liferay.docs.scriptutil`
project. Note that the parent project contains only two files, `build.gradle`
and `settings.gradle`, besides the API and implementation subprojects. The
contents of the `build.gradle` file is not strictly necessary:

    task wrapper(type:Wrapper) {
        gradleVersion = '2.6'
    }

This `build.gradle` file simply defines a `wrapper` task that you can run to add
the Gradle wrapper to your project. The Gradle wrapper allows the project build
to run on systems in which Gradle has not been installed. To add the Gradle
wrapper to your project, run `gradle wrapper`. This has already been done in the
sample project:
[https://github.com/liferay/liferay-docs/tree/master/discover/deployment/code/com.liferay.docs.scriptutil](https://github.com/liferay/liferay-docs/tree/master/discover/deployment/code/com.liferay.docs.scriptutil).
The `settings.gradle` file specifies your project's subprojects:

    include 'com.liferay.docs.scriptutil.api', 'com.liferay.docs.scriptutil.impl'

Next, let's look at the API subproject. This project contains only three files.
`ScriptUtil.java` is the interface that defines the method signatures of your
scripting utility methods:

    package com.liferay.docs.scriptutil.api;

    public interface ScriptUtil {
            
        public String operationOne(); 

        public String operationTwo(String name);	

    }

This jnterface defines two methods. The first takes no arguments, the second
takes a string argument.

The `bnd.bnd` file is required for building a Liferay module:

    Bundle-Name: Script Util API
    Bundle-SymbolicName: com.liferay.docs.scriptutil.api
    Bundle-Version: 1.0.0.${tstamp}
    Export-Package: com.liferay.docs.scriptutil.api

Notice that the `com.liferay.docs.scriptutil.api` module is an exported package.
This must be the case if you want to be able to use the `ScriptUtil` class
outside of the `com.liferay.docs.scriptutil.api` module.

The API project's `build.gradle` file was generated by Blade Tools. It applies
the `biz.aQute.bnd.builder` Gradle plugin that's used for creating modules. It
also configures a few repositories and dependencies. By default, the
dependencies include Liferay's portal service JAR and the OSGi compendium JAR.

Lastly, let's look at the implementation subproject. This project also contains
only three files. `ScriptUtilImpl.java` is a component class that implements the
`ScriptUtil` interface:

    package com.liferay.docs.scriptutil.impl;

    import org.osgi.service.component.annotations.Component;

    import com.liferay.docs.scriptutil.api.ScriptUtil;
    import com.liferay.portal.kernel.log.Log;
    import com.liferay.portal.kernel.log.LogFactoryUtil;

    @Component(
        immediate = true,
        property = {
        },
        service = ScriptUtil.class
    )
    public class ScriptUtilImpl implements ScriptUtil {

        @Override
        public String operationOne() {
            _log.debug("Inside of operation one!");

            return "Hello world!";
        }

        @Override
        public String operationTwo(String name) {
            _log.debug("Inside of operation two!");

            return "Hello " + name + "!";
        }

        private static Log _log = LogFactoryUtil.getLog(ScriptUtilImpl.class); 
    }

The line `service = ScriptUtil.class` in the `@Component` annotation instructs
Liferay's module framework to register the `ScriptUtilImpl` class as an OSGi
service of type `ScriptUtil`. This is an example of
[Declarative Services](http://wiki.osgi.org/wiki/Declarative_Services) in
action.

The implementation project's `bnd.bnd` is very similar to the API project's
`bnd.bnd` file:

    -dsannotations: *
    Bundle-Name: Script Util Impl
    Bundle-SymbolicName: com.liferay.docs.scriptutil.impl
    Bundle-Version: 1.0.0.${tstamp}
    Private-Package: com.liferay.docs.scriptutil.impl

Notice two differences. First, since your implementation project uses
declarative services, you should add the line `-dsannotations: *`. Second,
there's no need to export the `com.liferay.docs.scriptutil.impl` package. If
another module wants to consume the `ScriptUtil` service, they can obtain an
instance from the service registry of Liferay's module framework. The Groovy
script in the next section demonstrates one way to do this.

The implementation project's `build.gradle` file is very similar to the
`build.gradle` file of the API project. However, it includes this extra line in
the dependencies section:

    compile  project(':com.liferay.docs.scriptutil.api')

This line is necessary since the implementation project needs access to the API
project at compile time.

When you've finished developing your project, you can build it by running
`gradle build` from the parent project's root folder: the
`com.liferay.docs.scriptutil` folder. This build generates JAR files in each
subproject in the
`com.liferay.docs.scriptuil/com.liferay.docs.scriptuil.api/build/libs` and
`com.liferay.docs.scriptuil/com.liferay.docs.scriptuil.impl/build/libs` folders.
To deploy the generated JARs using Blade Tools, use the following commands:

    blade deploy com.liferay.docs.scriptutil.api/build/libs/com.liferay.docs.scriptutil.api-1.0.jar

    blade deploy com.liferay.docs.scriptutil.impl/build/libs/com.liferay.docs.scriptutil.impl-1.0.jar

Once these modules have been deployed, you're ready to invoke your scripting
utilities from Liferay's script engine.

## Using Custom Scripting Utilities in a Script

To see the `ScriptUtil` code in action, navigate to the *Control Panel*. Expand
the *System* heading and click on *Server Administration* and then *Script* to
access the script console. Make sure that the script language is set to Groovy.
Then enter the following script: 

    import com.liferay.docs.scriptutil.api.ScriptUtil;

    import org.osgi.framework.Bundle;
    import org.osgi.framework.BundleContext;
    import org.osgi.framework.FrameworkUtil;
    import org.osgi.util.tracker.ServiceTracker;

    Bundle bundle = FrameworkUtil.getBundle(ScriptUtil.class);
    BundleContext context = bundle.getBundleContext();
    ServiceTracker tracker = new ServiceTracker(context, ScriptUtil.class.getName(), null);
    tracker.open();
    ScriptUtil util = tracker.getService();

    out.println(util.operationOne());
    out.println(util.operationTwo("Joe Bloggs"));

Click *Execute* and you should see the results of your script displayed right
under the script console.

How does this script work? The `Bundle`, `BundleContext`, `FrameworkUtil`, and
`ServiceTracker` classes are all part of Liferay's OSGi-based module framework.
The `out` variable is one of the predefined variables that's available in
Liferay's script console. Note: Both the API and the implementation modules of
your scripting utilities project must be deployed in order for your script to
work. Furthermore, you should always be prepared for a runtime exception to
occur. For example, if one or more modules are uninstalled while a script is
running, various OSGi services could become unavailable during the execution of
the script.

## Related Topics

[Invoking Liferay Services From Scripts](/discover/deployment/-/knowledge_base/7-0/invoking-liferay-services-from-scripts)

[Running Scripts From the Script Console](/discover/deployment/-/knowledge_base/7-0/running-scripts-from-the-script-console)

[Leveraging the Script Engine in Workflow](/discover/deployment/-/knowledge_base/7-0/leveraging-the-script-engine-in-workflow)
